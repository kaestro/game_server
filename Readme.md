# **간단한 C++ 게임 서버 프로젝트**

## 🌟 프로젝트 개요

이 저장소는 C++을 기반으로 간단한 게임 서버를 처음부터 개발하는 과정을 담고 있습니다.

프로젝트는 C++ 표준 라이브러리와 운영체제 수준의 소켓 API만을 사용한 기본적인 TCP 에코 서버 구축부터 시작하여, 점진적으로 사용자 로그인, 스테이지(존) 진입, 기본적인 전투 시스템과 같은 핵심 게임 기능을 구현합니다. 주요 목표는 단계별 실습을 통해 이론적 배경, 코드 예시, 발생 가능한 문제점 및 해결 방안을 제시하여 실질적인 개발 능력을 함양하는 것입니다.

---

## 🛠️ 빌드 방법 (CMake 사용)

이 프로젝트는 CMake를 사용하여 빌드합니다. 다음 단계를 따라 빌드하십시오.

1.  **CMake 설치**:
    운영체제에 맞는 CMake 설치 방법을 따르십시오. (예: `sudo apt install cmake` on Debian/Ubuntu)

2.  **저장소 클론**:
    ```bash
    git clone https://github.com/kaestro/game_server.git
    cd game_server

    ```

3.  **빌드 디렉토리 생성 및 CMake 실행**:
    프로젝트 루트 디렉토리에서 다음 명령을 실행합니다.
    ```bash
    mkdir build
    cd build
    cmake ..
    ```
    이 명령은 `build` 디렉토리를 생성하고, 해당 디렉토리로 이동한 후 상위 디렉토리의 `CMakeLists.txt` 파일을 사용하여 빌드 환경을 구성합니다.

4.  **컴파일**:
    `build` 디렉토리 내에서 다음 명령을 실행하여 프로젝트를 컴파일합니다.
    ```bash
    make
    ```
    컴파일이 성공하면 `build` 디렉토리에 `MyGameServer` (또는 CMakeLists.txt에서 지정한 실행 파일 이름) 실행 파일이 생성됩니다.

5.  **서버 실행**:
    `build` 디렉토리 내에서 다음 명령으로 서버를 실행할 수 있습니다.
    ```bash
    ./MyGameServer
    ```

---

## 📚 로드맵 및 구현된 기능

이 프로젝트는 다음과 같은 주요 개발 단계로 구성됩니다:

### **1단계: 기본적인 TCP 에코 서버 및 클라이언트 구현, 네트워크 및 개발 환경 기초**
*   **목표:** 기본적인 에코 서버와 클라이언트를 구현하여 소켓 프로그래밍 및 기초적인 C++ 동시성/메모리 관리 기법을 파악하고, 필수적인 네트워크 지식 및 개발 환경을 구축합니다.
*   **주요 구현 내용:**
    *   **단일 클라이언트 에코 서버/클라이언트:**
        *   순수 C++ 및 OS별 소켓 API 사용 (Linux/macOS용 POSIX 소켓, Windows용 Winsock).
        *   `socket()`, `bind()`, `listen()`, `accept()`, `connect()`, `send()`, `recv()`, `close()` 함수 사용법.
        *   헤더 파일(`.h`)과 소스 파일(`.cpp`) 분리를 통한 기본적인 코드 구조화.
    *   **CMake 빌드 시스템 도입:**
        *   CMake 설치.
        *   서버 및 클라이언트 컴파일을 위한 기본적인 `CMakeLists.txt` 작성.
        *   CMake를 사용한 프로젝트 빌드 (위에 설명된 빌드 방법 참조).
    *   **`std::thread`를 이용한 다중 클라이언트 처리 (다음 단계):**
        *   각 클라이언트에 대해 새 스레드를 생성하여 여러 클라이언트를 동시에 처리하도록 서버 수정.
        *   "클라이언트당 스레드(thread-per-client)" 모델 및 장단점 논의.
    *   **`std::mutex` 및 `std::lock_guard`를 이용한 기초적인 동기화 (향후 단계):**
        *   공유 자원 식별 (예: `std::cout`, 추후 공유 데이터 구조).
        *   `std::mutex`를 사용하여 경쟁 조건(race condition)으로부터 공유 자원 보호.
        *   RAII 기반 뮤텍스 관리를 위한 `std::lock_guard` 사용.
    *   **스마트 포인터 (`std::unique_ptr`, `std::shared_ptr`) 활용 기초 (향후 단계):**
        *   RAII 원칙을 활용한 동적 메모리 관리의 중요성 이해.
        *   `std::unique_ptr`: 단독 소유권을 가지는 동적 객체 관리 (예: 클라이언트별 처리 객체, 스레드 내 자원).
        *   `std::shared_ptr`: 공유 소유권을 가지는 동적 객체 관리 (예: 여러 스레드에서 접근해야 하는 공유 리소스 객체).
        *   `new`/`delete` 직접 사용 시 발생할 수 있는 메모리 누수 및 매달린 포인터 문제 방지.
*   **결과물:** CMake로 빌드 가능하며, 헤더/소스 파일로 구조화된 단일 스레드 TCP 에코 서버 및 클라이언트, 그리고 안정적인 개발 환경.

### **2단계: 통신 프로토콜 설계 및 사용자 관리 기초**
*   **목표:** 간단한 통신 프로토콜을 설계하고 사용자 로그인 기능을 구현합니다.
*   **주요 구현 내용:**
    *   **기본 프로토콜 설계:**
        *   프로토콜의 개념.
        *   간단한 메시지 구조 정의: 헤더(메시지 타입, 메시지 길이)와 바디(본문).
        *   `MessageType`에 `enum class` 사용, 메시지 헤더 및 바디에 `struct` 사용.
    *   **간단한 데이터 직렬화:**
        *   직렬화/역직렬화 개념.
        *   기본적인 구조체 직렬화를 위한 `memcpy` 사용 (단점 논의: POD 타입, 엔디언, 패딩, 포인터).
    *   **사용자 로그인 구현:**
        *   기본적인 서버 측 사용자 데이터 표현 (예: 사용자 이름/비밀번호 저장을 위한 `std::map`).
        *   `LoginRequest` 처리 및 `LoginResponse` 전송.
        *   기본적인 세션 관리 (예: 성공적인 로그인 후 클라이언트 소켓을 사용자 이름에 매핑).
        *   `std::mutex`를 사용하여 공유 사용자 데이터 및 세션 데이터 보호.
    *   **결과물:** 사용자 정의 메시지를 처리하고, 사용자를 인증하며, 기본 세션을 관리할 수 있는 서버.

### **3단계: 핵심 게임 기능 구현**
*   **목표:** 기본적인 게임 메커니즘 구현: 스테이지 관리 및 간단한 전투 시스템.
*   **주요 구현 내용:**
    *   **스테이지 관리:**
        *   "스테이지" 또는 "존" 정의 (예: 로비, 숲, 동굴).
        *   서버 측 플레이어 위치 추적 로직 (예: `std::map<username, StageID>`).
        *   클라이언트의 `EnterStageRequest` 처리 및 플레이어 위치 업데이트.
        *   클라이언트에 `EnterStageResponse` 전송.
    *   **기본적인 전투 시스템 (액션 기반):**
        *   전투를 개별 액션으로 정의 (예: 플레이어 A가 플레이어 B/몬스터 X를 공격).
        *   플레이어/몬스터 능력치 관리 (예: HP, 공격력을 `std::map<username, PlayerStats>`에 저장).
        *   전투 관련 메시지 정의 (`CombatActionRequest`, `CombatEventUpdate`).
        *   서버 측 전투 로직:
            *   액션 유효성 검사.
            *   피해량 계산 (간단한 공식 사용).
            *   HP 업데이트 (뮤텍스 보호).
            *   관련 클라이언트에 전투 결과 알림.
    *   **간단한 퀘스트 시스템:**
        *   퀘스트 개념 정의: 고유 ID, 제목, 설명, 목표(예: 특정 몬스터 처치, 아이템 수집), 보상.
        *   **서버 측 퀘스트 로직:**
            *   미리 정의된 퀘스트 데이터 관리 (예: `std::vector<QuestData>`).
            *   플레이어 퀘스트 상태 추적 (예: `std::map<username, PlayerQuestProgress>`), 수락한 퀘스트, 진행 상황, 완료 여부 관리.
            *   퀘스트 관련 메시지 타입 정의 (예: `RequestQuestList`, `QuestListResponse`, `AcceptQuestRequest`, `CompleteQuestRequest`, `QuestUpdate`).
            *   클라이언트의 퀘스트 목록 요청, 수락, 완료 요청 처리.
            *   (간단화된) 퀘스트 목표 달성 조건 확인 (예: 전투 시스템과 연동하여 몬스터 처치 수 카운트).
            *   퀘스트 완료 시 보상 지급 로직 (예: 경험치, 가상 화폐).
        *   **클라이언트 측 퀘스트 처리:**
            *   수락 가능한 퀘스트 목록 및 진행 중인 퀘스트 정보 UI 표시.
            *   플레이어의 퀘스트 수락/포기/완료 상호작용.
            *   서버로부터 퀘스트 진행 상황 업데이트 수신 및 UI 반영.
    *   **결과물:** 다양한 게임 스테이지에서 플레이어의 존재를 관리하고, 간단한 전투 상호작용 및 기본적인 퀘스트 수행을 처리할 수 있는 서버.

### **4단계: 개선 및 향후 학습 방향**
*   **목표:** 코드 품질 및 안정성을 향상시키고 추가 학습을 위한 경로를 제시합니다.
*   **주요 내용:**
    *   **기본적인 오류 처리 및 로깅:**
        *   견고한 소켓 오류 검사 (반환 값, `errno`/`WSAGetLastError()`).
        *   `recv()` 반환 값 올바르게 처리 (정상 종료 시 0, 오류 시 <0).
        *   간단한 파일 로깅 (`std::ofstream`) (타임스탬프, 로그 레벨, 스레드 ID 포함).
    *   **코드 리팩토링 원칙 소개:**
        *   함수 추출, 변수/함수 이름 변경, 중복 코드 제거, 매직 넘버를 명명된 상수로 변경, 조건문 단순화.
    *   **메모리 관리 모범 사례 (C++):**
        *   RAII (Resource Acquisition Is Initialization).
        *   스마트 포인터 (`std::unique_ptr`, `std::shared_ptr`)의 심화 사용 및 이점 재확인.
    *   **고급 주제 간략 소개 (향후 학습 방향):**
        *   비동기 I/O (예: Boost.Asio, C++20 코루틴).
        *   논블로킹 소켓과 이벤트 멀티플렉싱 (`select`, `poll`, `epoll`/`kqueue`/IOCP).
        *   더 견고한 직렬화 (Protocol Buffers, FlatBuffers, MessagePack).
        *   데이터베이스 연동 (SQL/NoSQL).
        *   보안 (입력 유효성 검사, 암호화, DDoS 방어).
        *   고급 동시성 패턴 (스레드 풀, 메시지 큐).
        *   메모리 풀 및 커스텀 할당자.
        *   Reliable UDP (RUDP).
    *   **결과물:** 더 견고하고 유지보수하기 쉬운 코드, 그리고 게임 서버 개발 심화 학습을 위한 명확한 로드맵.

---

## 📜 라이선스

이 프로젝트는 GNU General Public License v3 (GPLv3)에 따라 라이선스가 부여됩니다. 자세한 내용은 [LICENSE.md](LICENSE.md) 파일을 참조하십시오.
